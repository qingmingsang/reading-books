# keep-alive
有很多文章都说 http2 相比 http1.1 增加了连接复用。这句话其实是不准确的。

在 HTTP 1.1 中 所有的连接默认都是持续连接，除非特殊声明不支持。 
而在 http1.0 中，官方没有支持 keep-alive, 通常会手动在请求头中添加 Connection: Keep-Alive。

keep-alive 就是 TCP 连接复用的开端。改善的效果就是不再重新建立TCP连接，省去 三次握手 的时间。

优点：
较少的CPU和内存的使用（由于同时打开的连接的减少了）
允许请求和应答的HTTP管线化
降低拥塞控制 （TCP连接减少了）
减少了后续请求的延迟（无需再进行握手）
报告错误无需关闭TCP连接

缺点：
长时间的 tcp 连接容易导致系统资源无效占用，浪费系统资源

# pipelining(管线化)
pipelining可以看作为keepa-live的一种升华，因为pipeline也是基于长连接的，目的就是利用一个连接做多次请求。
连接请求头使用keepalive之后，在处理多个请求时，第二个请求要等到第一个请求响应完成才能发起，两个响应时间至少为2RTT。
而对于pipeline，客户端请求是打包进行的，第二个请求不必等第一个请求处理完，两个响应的时间可能达到1RTT。

pipeline将若干个请求排队串行化单线程(请求)处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞(HOL blocking)；

所以keep-alive(pipelining) 的劣势也很明显：
- Keep-Alive可能会极大的影响服务器性能，因为它在文件被请求之后还保持了不必要的连接很长时间
- 可能发生队头阻塞（HOL blocking），造成延迟
- 所有遵循 HTTP/1.1 的代理和服务器都应该支持流水线，虽然实际情况中还是有很多限制：一个很重要的原因是，仍然没有现代浏览器去默认支持这个功能。

# 什么是HTTP Pipeline
http管线化是一项实现了多个http请求但不需要等待响应就能够写进同一个socket的技术，仅有http1.1规范支持http管线化，1.0并不支持；
采用管线化的请求会对页面载入时间产生动态的提高，尤其是当通过高延迟的网络,例如通过卫星网络连接；
普通情况下通过同一个tcp数据包发送多个http请求，而http管线化向网络上发送更少的tcp数据包，大幅减轻网络负载；
只有幂等的请求能够被管线化，例如get和head请求；
post请求不应该被管线化；
新建立连接的请求因为无法判断源服务器(代理服务器)是否支持http1.1协议，也不应该被管线化处理。所以，仅在重用已经成功建立的持久化连接的情况下,才可以使用管线化。
http管线化需要客户端和服务器双方都能够支持，http1.1规定服务器必须支持管线化，但并未提及服务器必须管线化响应信息，但如果客户端选择管线化的通信方式，服务器必须能够支持和受理。

## HTTP Pipeline优势
减少cpu和内存占用(因为同一时间，启用更少的连接)
减轻网络堵塞(建立更少的连接)
减轻后续请求的延迟(因为避免建立新连接而减频繁的握手)
不采用管道化意味着每次请求必须被应答之后，它的连接才能空闲以便发送下一次请求；
不采用管道化会导致平均每个连接带来额外的延迟，或者如果你的服务器不支持http长连接，进行其他的tcp三次握手增加了额外的请求往返，双倍延迟；
不需要牺牲当前的tcp连接, 就能够报告错误.
根据RFC 2616 (page 47),一个单用户客户端对于任何一台服务器或者代理服务器都可以维护不多于两个的连接数.
在当前由n台服务器组成的网络中, 任意一台代理服务器对另外的服务器或者代理服务器应该维护2*n个连接.
这些指南目的在于提升http响应性能,避免网络堵塞.

# 什么是http长连接
http持久化连接也称http长连接或者http连接复用,思想是使用同一个tcp连接去发送和接收多个http请求/响应,以便避免为每次单独的请求/应答建立新的连接.

https://ainyi.com/44
https://my.oschina.net/u/3434392/blog/1838812
https://segmentfault.com/a/1190000013594849