# 1. 创建函数
## 函数声明
```
function fnName(){

}
```

## 函数表达式
```
var fnName = function(){

}
```

## 使用Function构造函数
Function 接收任意多的参数，但最后一个参数总被认为是函数体，前面的参数是传入新函数的参数
```
var fnName = new Function(a, b, c, 'return a + b + c')
```

## 箭头函数
```
var fnName = () => {

}
```

# 2. 函数的内部属性
## anguments
- 类型：类数组对象，包含着传入函数的所有参数，和length属性.
- 属性：  
    - `anguments.length`  : 实际传入函数参数的个数
    - `anguments.callee`  : 指向拥有这个anguments对象的函数，即函数本身.(严格模式报错)

## this
函数据已执行的执行环境.
箭头函数无 this.

# 3. 函数的属性和方法 
## 属性
`fnName.caller` : 保存着调用当前函数的函数的引用，如果在全局作用域调用当前函数，则返回 null

`fnName.length` : 表示函数希望接收的命名参数的个数.
`anguments.length` 是实际传入函数参数的个数，而 `fnName.length` 是函数希望接收命名参数的个数.
ES6函数默认值对length的影响 ：指定默认值以及在指定默认值的参数之后的所有参数，都不会计算到length中.

`fnName.prototype` ：保存函数的原型对象

`fnName.name` ：获取函数的函数名.
  返回值：
- 对于函数声明：返回函数名
- 对于匿名函数表达式：ES5返回空字符串，ES6返回变量的名字
- 对于具名函数表达式：返回函数的原名字
- 对于使用 new Function 创建的函数：返回 'anonymous'
- 对于使用bind方法返回的函数：返回 'bound 函数名'

## 方法
`fnName.apply()`  `fnName.call()`
上面两个方法都用来在特殊的作用域调用函数，实际上等于设置函数体内的 this 对象的值
第一个参数: 都是 this 的值,
第二个参数: apply 接收 anguments 对象或数组，call 必须逐个列举出来

`fnName.bind(thisArg, [, arg1[, arg2[, ...]]])` :
根据已有函数，创建一个被绑定新 this 值的函数
    参数：
        第一个参数是 this 的值
        arg1、arg2、arg3...：这些参数将被传入原始函数，且前置与调用原始函数时所传递的参数
    返回值：
        {Function} 被指定 this 值的新函数
