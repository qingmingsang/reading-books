# 数据维度
* pv： 访问人次，一般每次刷新页面都会 + 1
* uv： 访问人数，每人一天内只计数一次，一般小于等于pv
* ip数：访问的ip数量
* 跳出率：打开一个网页的概率／总的网页访问数
* 平均访问时长：访问总时长 / 访问页数
* 平均访问深度：在当前域名跳转的次数 / 访问次数
* 会话数：用户发起的session的数量
* 路由切换量（rpv）：由于当前很多较复杂的网站都是采用spa结构，使用传统的pv，uv不能反映用户真实使用状况，所以这个指标就显得非常重要了，一般来说路由切换一次 rpv + 1，最终得到一个路由访问的次数

## 页面加载耗时
主要是收集由performace.timing对象提供计算出的各种时间实现的


## 全链路状态感知
全链路状态感知，也称作端到端的全链路监控，基本会收集从请求从 web server 到 db 的全生命周期的状态，基本会记录整个请求在处理过程中各个环节的具体耗时等信息。

## pv，uv
通常的方式对访问当前域名的一个用户植入一个cookies用于标识用户身份，以传统的统计口径来看，对于pv，每次刷新页面都 + 1，对于uv，在今天内访问的用户只会 + 1。这里有几个注意点:
* 1、统计口径：对于不同的产品，pv的统计口径可能是不一样的，有的要求首页完全加载完才算一个pv，有的要求曝光1/4，有的需要dom加载完。根据需求的不同，绑定上报事件的时机也不同。对于监控系统来说，一般会实现通用口径的pv统计，如果有其他不同需求，可以走后文提到的自定义上报流程。
* 2、防刷：对于pv/uv，有很多刷流量的方式，比如删掉cookies，重新加载一次。对有账号体系的系统，cookies和账号绑定就可以防刷。对没有账号体系的系统，可以使用ip来限制，同ip发起多少次都算一个uv。防刷是个比较有趣的话题，限于篇幅，这儿简略提一下，有兴趣的同学可以一起进一步探讨。
* 3、spa网页：由于前端路由的存在，spa结构的网页，传统的pv很难反应网站的真实状况，推荐使用uv或者rpv来观测。

##  ip数
访问ip数的统计有多种方式，这里介绍两种主要方式：
* 1、接入层直接记录：在接入层入口直接记录来源ip，收到就 + 1，如有需要详情也可以记录更多信息，这种方式可能会增加当前系统的一些负担。改造成MQ或者其他的异步方式，可以减轻对主干系统的影响。
* 2、分析日志：主流做法，分析接入层日志，对日志做统计即可得出ip数。

## 跳出率
根据上文提到的跳出率公式，需要计算当前页面的打开次数，对于非spa且非hash的页面，都可以用接入层统计的方式来计算url的打开次数。对使用hash路由的spa页面，需要绑定hashchange事件或者框架提供的路由事件来进行上报。总访问页数同理。

## 平均访问时长 / 平均访问深度
根据计算公式，统计方法类似跳出率。

## 会话数量
这个没太多好说的，服务端统计就完事了。

## 路由切换量（rpv）
随着前端路由系统的普及，当前 spa 是web系统的主要形态之一，对spa系统来说，统计的实现方式和 mpa 系统有很多的不同，一般来说统计路由切换量（rpv）需要手动开启配置，比如阿里云arms就需要配置`enableSPA = true`。

前端路由主要是通过hash和history api来实现的，使用hash路由时hash值不会上传服务器，需要前端来做捕获上报，而history api的情况url是变化的，可以在后台统计到。

hash路由的捕获上报实现：
```
// hash路由绑定onhashchange事件
    if("onhashchange" in window) {
        window.onhashchange = handler
    }
```
如果前端需要通过 history api来统计，这里也给出一些代码实例
```
    // history api类型路由的上报
    // 监听popstate
    // history 只监听 popstate事件可以处理掉大部分的api触发
    window.addEventListener('popstate', (event) => {
        // 上报处理
        handler()
    })
    // pushState 和 replaceState 不会触发 popstate 事件，可以采用类似xhr的方式重写
```

## 自定义埋点
自定义埋点上报，涉及到各监控系统api设计，一般来说，各监控系统的接入sdk都会给出自定义上报的方法，供业务系统自己控制上报时机和上报内容。 举例：

```
// 自定义埋点实例,指定类型type，服务器解析数据并呈现
    monitor.diysend({type:'monitor', value: 't1=1&t2=2'})
```

## 点击流
点击流其实是通过根据统一的用户标识把一系列的事件上报的用户行为串起来的一种方式，结合以上的数据上报和页面切换，可以构造出一个基于时间轴的用户点击操作流程。

