1.客户端发起HTTPS请求
2.服务端配置数字证书
3.传送证书,这个证书里有公钥等内容，同时服务端把证书内容做一次HASH，然后用私钥加密形成数字签名
4.客户端解析证书，验证公钥有效，用公钥解密数字签名
5.用公钥加密传送随机值（master-key），服务度获取到后用私钥解密，之后这个随机值成为两者通信的私钥（session-key），保证数据完整性的hash-key。
6.客户端用HASH key 生成一个MAC（ Message Authentication Code），附在HTTP报文的后面，然后用session key 加密所有数据（HTTP + MAC），然后发送出去
7.服务器先用session key 解密数据，得到HTTP + MAC，然后自己用相同的算法计算自己的MAC，如果两个MAC相等，则数据没有被篡改。

对称加密：
- 加密和解密都是用同一个密钥

非对称加密：
- 加密用公开的密钥，解密用私钥(私钥只有自己知道，公开的密钥大家都知道)

数字签名：
- 验证传输的内容是对方发送的数据
- 发送的数据没有被篡改过

数字证书 (Certificate)
- 认证机构证明是真实的服务器发送的数据。


# 流程：
1.客户端发起HTTPS请求
用户在浏览器里输入一个https网址，然后连接到server的443端口。

2.服务端的配置
采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。

3.传送证书,这个证书其实就是公钥
只是包含了很多信息，如证书的颁发机构，过期时间等等。

4.客户端解析证书
这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值。然后用证书对该随机值进行加密。

5.传送加密信息
这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。

6.服务段解密信息
服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。

7.传输加密后的信息
这部分信息是服务段用私钥加密后的信息，可以在客户端被还原

8.客户端解密信息
客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。

# 流程：
1. 用户向web服务器发起一个安全连接的请求
2. 服务器返回经过CA认证的数字证书，证书里面包含了服务器的public key(公钥)
3. 用户拿到数字证书，用自己浏览器内置的CA证书解密得到服务器的public key
4. 用户用服务器的public key加密一个用于接下来的对称加密算法的密钥，传给web服务器
5. 因为只有服务器有private key可以解密，所以不用担心中间人拦截这个加密的密钥
6. 服务器拿到这个加密的密钥，解密获取密钥，再使用对称加密算法，和用户完成接下来的网络通信

# 3y的通讯之路：
远古时代：
3y和女朋友聊天传输数据之间没有任何的加密，直接传输
内容被看得一清二楚，毫无隐私可言

上古时期：
使用对称加密的方式来保证传输的数据只有两个人知道
此时有个问题：密钥不能通过网络传输(因为没有加密之前，都是不安全的)，所以3y和女朋友先约见面一次，告诉对方密码是多少，再对话聊天。

中古时期：
3y不单单要跟女朋友聊天，还要跟爸妈聊天的哇(同样不想泄漏了自己的通讯信息)。那有那么多人，难道每一次都要约来见面一次吗？(说明维护多个对称密钥是麻烦的！)--->所以用到了非对称加密
3y自己保留一份密码，独一无二的(私钥)。告诉3y女朋友，爸妈一份密码(这份密码是公开的，谁都可以拿--->公钥)。让他们给我发消息之前，先用那份我告诉他们的密码加密一下，再发送给我。我收到信息之后，用自己独一无二的私钥解密就可以了！

近代：
此时又出现一个问题：虽然别人不知道私钥是什么，拿不到你原始传输的数据，但是可以拿到加密后的数据，他们可以改掉某部分的数据再发送给服务器，这样服务器拿到的数据就不是完整的了。
3y女朋友给3y发了一条信息”3y我喜欢你“，然后用3y给的公钥加密，发给3y了。此时不怀好意的人截取到这条加密的信息，他破解不了原信息。但是他可以修改加密后的数据再传给3y。可能3y拿到收到的数据就是”3y你今晚跪键盘吧“

现代：
拿到的数据可能被篡改了，我们可以使用数字签名来解决被篡改的问题。数字签名其实也可以看做是非对称加密的手段一种，具体是这样的：得到原信息hash值，用私钥对hash值加密，另一端用公钥解密，最后比对hash值是否变了。如果变了就说明被篡改了。(一端用私钥加密，另一端用公钥解密，也确保了来源)

目前现在：
好像使用了数字签名就万无一失了，其实还有问题。我们使用非对称加密的时候，是使用公钥进行加密的。如果公钥被伪造了，后面的数字签名其实就毫无意义了。讲到底：还是可能会被中间人攻击~此时我们就有了CA认证机构来确认公钥的真实性！

https://zhuanlan.zhihu.com/p/36981565





基于ssl
https://blog.csdn.net/xiaopang_yan/article/details/78709574

https://blog.csdn.net/luweicheng24/article/details/80579731

https://zhuanlan.zhihu.com/p/27395037



HTTPS 协议是由 HTTP 加上 TLS/SSL 协议构建的可进行加密传输、身份认证的网络协议，主要通过数字证书、加密算法、非对称密钥等技术完成互联网数据传输加密，实现互联网传输安全保护。设计目标主要有三个。
（1）数据保密性：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么 [4]  。
（2）数据完整性：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 [4]  。
（3）身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方 [4]  。


双向的身份认证
客户端和服务端在传输数据之前,会通过基于X.509证书对双方进行身份认证 。具体过程如下 [3]  :
客户端发起 SSL 握手消息给服务端要求连接。
服务端将证书发送给客户端。
客户端检查服务端证书，确认是否由自己信任的证书签发机构签发。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。
服务端要求客户端发送证书，并检查是否通过验证。失败则关闭连接，认证成功则从客户端证书中获得客户端的公钥，一般为1024位或者 2048位。到此，服务器客户端双方的身份认证结束，双方确保身份都是真实可靠的。


数据传输的机密性
客户端和服务端在开始传输数据之前，会协商传输过程需要使用的加密算法。 客户端发送协商请求给服务端, 其中包含自己支持的非对成加密的密钥交换算法 ( 一般是RSA), 数据签名摘要算法 ( 一般是SHA或者MD5) , 加密传输数据的对称加密算法 ( 一般是DES),以及加密密钥的长度。 服务端接收到消息之后，选中安全性最高的算法，并将选中的算法发送给客户端，完成协商。客户端生成随机的字符串，通过协商好的非对称加密算法，使用服务端的公钥对该字符串进行加密，发送给服务端。 服务端接收到之后，使用自己的私钥解密得到该字符串。在随后的数据传输当中，使用这个字符串作为密钥进行对称加密 [3]  。

防止重放攻击
SSL使用序列号来保护通讯方免受报文重放攻击。这个序列号被加密后作为数据包的负载。在整个SSL握手中,都有一个唯一的随机数来标记SSL握手。 这样防止了攻击者嗅探整个登录过程，获取到加密的登录数据之后，不对数据进行解密, 而直接重传登录数据包的攻击手法。
可以看到，鉴于电子商务等安全上的需求，HTTPS对比HTTP 协议，在安全方面已经取得了极大的增强。总结来说，HTTPS的改进点在于创造性的使用了非对称加密算法，在不安全的网路上，安全的传输了用来进行非对称加密的密钥，综合利用了非对称加密的安全性和对称加密的快速性 [3]  。

与HTTP原理区别编辑
HTTPS 主要由两部分组成：HTTP + SSL / TLS，也就是在 HTTP 上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过 TLS 进行加密，所以传输的数据都是加密后的数据。
HTTP 原理
① 客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过TCP 来完成的，一般 TCP 连接的端口号是80。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和许可内容 [2]  。
② 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容 [2]  。
HTTPS 原理
① 客户端将它所支持的算法列表和一个用作产生密钥的随机数发送给服务器 [2]  ；
② 服务器从算法列表中选择一种加密算法，并将它和一份包含服务器公用密钥的证书发送给客户端；该证书还包含了用于认证目的的服务器标识，服务器同时还提供了一个用作产生密钥的随机数 [2]  ；
③ 客户端对服务器的证书进行验证（有关验证证书，可以参考数字签名），并抽取服务器的公用密钥；然后，再产生一个称作 pre_master_secret 的随机密码串，并使用服务器的公用密钥对其进行加密（参考非对称加 / 解密），并将加密后的信息发送给服务器 [2]  ；
④ 客户端与服务器端根据 pre_master_secret 以及客户端与服务器的随机数值独立计算出加密和 MAC密钥（参考 DH密钥交换算法） [2]  ；
⑤ 客户端将所有握手消息的 MAC 值发送给服务器 [2]  ；
⑥ 服务器将所有握手消息的 MAC 值发送给客户端 [2]  。



# 加密的详细过程
- 首先服务器端用非对称加密（RSA）产生公钥和私钥
- 然后把公钥交给数字证书，并进行包装(生成数字签名)发给客户端
- 当公钥到达客户端之后，客户端的TLS首先验证公钥是否有效（颁发机构，公钥有效期，CA数字签名）
- 若存在问题则弹出警告框，提示证书存在问题
- 若证书没有问题，则客户端会用对称加密产生一个秘钥，并用服务端返回的公钥（非对称加密）对 对称加密 的秘钥加密后发送给服务器。这个秘钥就是以后用来通信的秘钥
- 这样服务器端收到公钥加密的秘钥就用自己的私钥解开公钥从而获得秘钥。
- 这样客户端和服务器都获得了秘钥，信息交流相对是安全的